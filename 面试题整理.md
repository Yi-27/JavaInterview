JUC（java.util.concurrent）Java高并发包

java.util.concurrent.atomic原子类包

# JMM（Java内存模型）

+ 是一种抽象的概念**并不真实存在**
+ 是一组规则活规范，通过规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式
+ JMM关于同步的规定：
  + 现场解锁前，必须把共享变量的值刷新回**主内存**
  + 线程加锁前，必须读取主内存的最新值到自己的**工作内存**
  + 加解锁是同一把锁



由于JVM运行程序的实体是线程，而每个现场创建时JVM都会为其创建一个工作内存（或称**栈空间**）

+ 工作内存是每个线程的私有数据区域

Java内存模型中规定所有变量都存储在**主内存（差不多就是指内存条）**，主内存是**共享内存区域**，所有线程都可以访问。

+ 但**线程对变量的操作（读写等）必须在工作内存中进行**
  + 首先要**将变量从主内存拷贝到自己的工作内存空间**
  + 然后对变量进行操作
  + 操作结束后，**再将变量写回主内存**
+ 不能直接操作主内存中变量，各个线程中的工作内存中存储着主存中的**变量拷贝副本**
  + 因此不同的线程间无法访问对象的工作内存
  + 线程间的通信（传值）必须通过主内存来完成



## JMM中的第一个特性：修改可见性

当一个线程修改主内存中的值，其他线程**立马**得到消息。

## JMM中的第二个特性：原子性

不可分割，完整性。

也即某个线程正在做某个具体业务时，中间不可以被加塞或者被分割。需要整体完整
要么同时成功，要么同时失败。



## JMM中的第三个特性：有序性

计算机在执行程序时，为了提高性能，编译器和处理器常常会对**指令做重排**

一般分为三种：

源代码 -> **编译器优化的重排** -> **指令并行的重排** -> **内存系统的重排** -> 最终执行的指令



**单线程环境**里面确保**程序最终执行结果**和**代码顺序执行的结果**一致。

处理器在进行重排序时必须要考虑指令之间的**数据依赖性**

**多线程环境**中线程交替执行，由于**编译器优化重排**的存在

+ 两个线程中使用的变量能否保证**一致性**是无法确定的，结果无法预测



#### 内存屏障(Memory Barrier）

volatile实现**禁止指令重排优化**，从而避免多线程环境下程序出现乱序执行的现象。
先了解一个概念，**内存屏障(Memory Barrier）**又称**内存栅栏**，是**一个CPU指令**，它的作用有两个:

+ 一是 保证特定操作的执行顺序，
+ 二是 保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）

由于**编译器和处理器都能执行指令重排优化**。

如果在指令间插入一条**Memory Barrier**则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说**通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化**。

内存屏障另外一个作用是**强制刷出各种CPU的缓存数据**，因此任何CPU上的线程都能读取到这些数据的最新版本。



对volatile变量进行写操作时：

+ 会在写操作后加入一条store屏障指令，将工作内存中的共享变量值刷新回到主内存
+ 普通读->普通写->**StoreStore屏障**->volatile写->**StoreLoad屏障**
  + **StoreStore屏障**将 **禁止** 前面的普通写和后面的volatile写重排序
  + **StoreLoad屏障**将 **防止** 上面的volatile写和后面可能有的volatile读/写重排序

对volatile变量进行读操作时：

+ 会在读操作前加入一条load屏障指令，从主内存中读取共享变量

+ volatile读->**LoadLoad屏障**->**LoadStore屏障**->普通读->普通写
  + **LoadLoad屏障**将 **禁止** 后面所有普通读操作和前面的volatile读重排序
  + **LoadStore屏障**将 **禁止** 后面所有的写操作和前面的volatile读重排序





工作内存与主内存同步延迟现象导致的可见性问题：
+ 可以使用synchronized或volatile关键字解决
+ 它们都可以使一个线程**修改后的变量立即对其他线程可见**

对于指令重排导致的可见性问题和有序性问题：

+ 可以利用volatile关键字解决，因为其另一个作用就是禁止重排序优化



#### DCL（Double Check Lock双端检锁机制）

这里时单例模式下的DCL

```java
// DCL（Double Check Lock双端检锁机制）
// 但是这个地方还是有极小的几率出错，是因为 指令重排 的存在
public static SingletonDemo getInstanceDCL(){
    if(instance == null){
        // 加锁前后都检测
        synchronized (SingletonDemo.class){
            if(instance == null){
                instance = new SingletonDemo();
            }
        }
    }
    return instance;
}
```

原因在于某一个线程执行到第一次检测，读取到instance不为null时，instance的引用对象**可能没有完成初始化**。

instance = new SingletonDemo();可以分为以下3步（伪代码）
+ memory = allocate(); // 1. 分配对象内存空间
+ instance(memory); // 2. 初始化对象
+ instance = memory; // 3. 设置instance指向刚分配的内存地址，此时instance!=null

步骤2和步骤3**不存在数据依赖关系**，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化时允许的。

那么就可能这样：
+ memory = allocate(); // 1. 分配对象内存空间
+ instance = memory; // 3. 设置instance指向刚分配的内存地址，此时instance!=null，**但是对象还没有初始化完成**
+ instance(memory); // 2. 初始化对象
这样就导致可能返回的instance为有地址，但是值为空

但是指令重排只会保证串行语义的执行的一致性（单线程），但并不会关心多线程间的语义一致性。
所以当一条线程访问instance不为null时，由于instance实力未必已初始化完成，也就造成了线程安全问题。



# CAS（比较并交换）

```java
public static void main(String[] args) {
    AtomicInteger atomicInteger = new AtomicInteger(5);

    // 主线程读其他事

    // 参数expect是指主物理内存上的值  update的值是打算写进去的值
    System.out.println(atomicInteger.compareAndSet(5, 2019) + "\t current data: " + atomicInteger.get());
    // 比较发现不是5了，就不写入2014，返所以回false
    System.out.println(atomicInteger.compareAndSet(5, 2014) + "\t current data: " + atomicInteger.get());
}
```



AtomicInteger类是基于底层的Unsafe类的

```java
public class AtomicInteger extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 6214790243416807050L;
// setup to use Unsafe.compareAndSwapInt for updates
private static final Unsafe unsafe = Unsafe.getUnsafe();
private static final long valueOffset;

static {
    try {
        valueOffset = unsafe.objectFieldOffset
            (AtomicInteger.class.getDeclaredField("value"));
    } catch (Exception ex) { throw new Error(ex); }
}

private volatile int value;
  // ...
}
```

变量value用volatile修饰，保证了多线程直接的可见性



```java
public final int getAndIncrement() {
    return unsafe.getAndAddInt(this, valueOffset, 1);
}
```
+ this是当前对象
+ valueOffset是内存偏移量
表示当前对象在内存中的值是多少。

变量valueOffset，表示该变量值在内存中的**偏移地址**
因为Unsafe就是根据内存偏移地址获取数据的



**那么UnSafe类是什么？**

+ 是CAS的核心类
+ 由于Java无法直接访问底层系统，需要通过本地(native）方法来访问
+ Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据
+ UnSafe类存在与sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，
  + 因为Java中CAS操作的执行**依赖于**UnSafe类的方法

**注意：**Unsafe类中的所有方法都是**native**修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务



CAS的全程为Compare-And-Swap，**它是一条CPU并发原语**。
它的功能是判断内存某个位置的值是否为预期值

+ 如果是则更改为新的值，这个过程是**原子的**。

CAS并发原语体现在Java语言中就是sun.misc.Unsafe类中的各个方法。
+ 调用UnSafe类中的CAS方法，JVM会帮我们实现**CAS汇编指令**。
+ 这是一种完全依赖于**硬件**的功能，通过它实现了原子操作

CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程。
并且，原语的执行必须是连续的，在执行过程中不允许被中断，也就是说**CAS是一条CPU的原子指令**，不会造成所谓的数据不一致问题。

```java
public final int getAndIncrement() {
    // this是当前对象 valueOffset是内存偏移量（就是内存地址）
    return unsafe.getAndAddInt(this, valueOffset, 1);
}
```

```java
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5; // var1 == this  var2 == valueOffset var4 == 1
    do {
        // 这一步就是找到这个位置上的值是多少，相当于拷贝到自己的工作内存中
        // 暂存的一个快照
        var5 = this.getIntVolatile(var1, var2); 
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); // 如果现在工作内存中快照与再与主内存上的值做比较
    	// 一样就可以修改值了(该方法的目的就是在前一个值基础上加1，即++)
    	// 不一样就再拷贝该位置上的最新值，再与该位置上的值进行比较
    	// 直至一样了并++了，才会跳出循环（这也说明没有别的线程插足先登）

    return var5;
}
```

该方法用来获取内存上的对应的值

```java
public native int getIntVolatile(Object var1, long var2);
```

该方法就是通过unsafe类调用CAS指令来比较并修改的

```java
public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
```

